# -*- coding: utf-8 -*-
"""Ikawa_Profile_Analysis_Tool

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VAxAvlop0rAM0zP-S6ix7y3leWJh-lav
"""

# Ikawa Profile Analysis Tool (Final Version - CSV)
# -*- coding: utf-8 -*-

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from streamlit_plotly_events import plotly_events
import io

# ==============================================================================
# í•µì‹¬ í•¨ìˆ˜
# ==============================================================================

def process_profile_data(df: pd.DataFrame, input_method: str) -> pd.DataFrame | None:
    """ë‹¨ì¼ í”„ë¡œíŒŒì¼ DFë¥¼ ë°›ì•„ ëª¨ë“  ë°ì´í„°ë¥¼ ê³„ì‚°í•˜ëŠ” í†µí•© í•¨ìˆ˜"""
    processed_df = df.copy()

    # ìˆ«ì ì—´ì„ ìˆ«ìë¡œ ë³€í™˜, ë³€í™˜ ë¶ˆê°€ ì‹œ ë¹ˆ ê°’(NaN) ì²˜ë¦¬
    cols_to_numeric = ['ì˜¨ë„â„ƒ', 'ë¶„', 'ì´ˆ', 'êµ¬ê°„(ì´ˆ)']
    for col in cols_to_numeric:
        if col in processed_df.columns:
            processed_df[col] = pd.to_numeric(processed_df[col], errors='coerce')

    processed_df.dropna(subset=['ì˜¨ë„â„ƒ'], inplace=True)
    if processed_df.empty: return None
    processed_df.reset_index(drop=True, inplace=True)
    processed_df.insert(0, 'ë²ˆí˜¸', processed_df.index)

    if input_method == 'ì‹œê°„ ì…ë ¥':
        processed_df['ë¶„'].fillna(0, inplace=True)
        processed_df['ì´ˆ'].fillna(0, inplace=True)
        total_seconds = processed_df['ë¶„'] * 60 + processed_df['ì´ˆ']
        processed_df['êµ¬ê°„(ì´ˆ)'] = total_seconds.diff()
    else: # êµ¬ê°„ ì…ë ¥
        processed_df['êµ¬ê°„(ì´ˆ)'].fillna(0, inplace=True)
        total_seconds = processed_df['êµ¬ê°„(ì´ˆ)'].cumsum()
        processed_df['ë¶„'] = (total_seconds // 60).astype('Int64')
        processed_df['ì´ˆ'] = (total_seconds % 60).astype('Int64')

    # ì²« í–‰ì˜ NaN êµ¬ê°„(ì´ˆ) ê°’ì„ 0ìœ¼ë¡œ ì±„ì›€
    processed_df['êµ¬ê°„(ì´ˆ)'].fillna(0, inplace=True)
    processed_df['ëˆ„ì (ì´ˆ)'] = processed_df['êµ¬ê°„(ì´ˆ)'].cumsum()

    temp_diff = processed_df['ì˜¨ë„â„ƒ'].diff()
    time_diff = processed_df['êµ¬ê°„(ì´ˆ)']
    where_condition = time_diff.fillna(0) != 0
    ror_per_sec = np.divide(temp_diff, time_diff, out=np.zeros_like(temp_diff, dtype=float), where=where_condition)
    processed_df['ROR(ì´ˆë‹¹)'] = pd.Series(ror_per_sec).fillna(0)

    return processed_df

def display_hover_info(hovered_time, selected_profiles, graph_data, colors):
    """ê·¸ë˜í”„ í˜¸ë²„ ì‹œ ë¶„ì„ íŒ¨ë„ì— ì •ë³´ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤."""
    st.markdown("#### ë¶„ì„ ì •ë³´")
    if hovered_time is None or not graph_data:
        st.info("ê·¸ë˜í”„ ìœ„ì— ë§ˆìš°ìŠ¤ë¥¼ ì˜¬ë¦¬ë©´ ìƒì„¸ ì •ë³´ê°€ í‘œì‹œë©ë‹ˆë‹¤.")
        return
    hover_sec = int(hovered_time)

    try:
        first_profile_name = next(name for name in selected_profiles if name in graph_data and graph_data[name] is not None)
        df_calc_first = graph_data[first_profile_name]

        if len(df_calc_first) > 1:
            temp_at_hover = np.interp(hover_sec, df_calc_first['ëˆ„ì (ì´ˆ)'], df_calc_first['ì˜¨ë„â„ƒ'])
        else:
            temp_at_hover = df_calc_first.loc[0, 'ì˜¨ë„â„ƒ']

        st.markdown(f"**{hover_sec // 60}ë¶„ {hover_sec % 60:02d}ì´ˆ ({hover_sec}ì´ˆ) / {temp_at_hover:.1f}â„ƒ**")
    except (StopIteration, KeyError, IndexError):
         return
    st.divider()
    for i, name in enumerate(selected_profiles):
        if name in graph_data:
            df_calc = graph_data.get(name)
            if df_calc is None: continue

            color = colors[i % len(colors)]

            current_segment = df_calc[df_calc['ëˆ„ì (ì´ˆ)'] <= hover_sec].iloc[-1:]
            if current_segment.empty: continue

            idx = current_segment.index[0]
            current_time = current_segment['ëˆ„ì (ì´ˆ)'].iloc[0]
            current_ror = current_segment['ROR(ì´ˆë‹¹)'].iloc[0]
            current_temp = current_segment['ì˜¨ë„â„ƒ'].iloc[0]

            is_on_point = abs(current_time - hover_sec) <= 0.5

            if is_on_point:
                display_temp = current_temp
                point_num = current_segment['ë²ˆí˜¸'].iloc[0]
                st.markdown(f"<span style='color:{color};'>â—</span> **{name}**: í¬ì¸íŠ¸ {int(point_num)}: {display_temp:.1f}â„ƒ (ì´ˆë‹¹ {current_ror:.3f}â„ƒ ìƒìŠ¹)", unsafe_allow_html=True)
            else:
                time_in_segment = hover_sec - current_time
                interp_temp = current_temp + current_ror * time_in_segment
                st.markdown(f"<span style='color:{color};'>â—</span> **{name}**: í¬ì¸íŠ¸ {int(current_segment['ë²ˆí˜¸'].iloc[0])}-{int(current_segment['ë²ˆí˜¸'].iloc[0]) + 1} êµ¬ê°„: {interp_temp:.1f}â„ƒ (ì´ˆë‹¹ {current_ror:.3f}â„ƒ ìƒìŠ¹)", unsafe_allow_html=True)

@st.cache_data
def create_template_csv(format_type):
    """ë‹¤ìš´ë¡œë“œìš© CSV í…œí”Œë¦¿ ë¬¸ìì—´ì„ ìƒì„±í•©ë‹ˆë‹¤."""
    if format_type == 'ì‹œê°„ ì…ë ¥':
        header = ",í”„ë¡œíŒŒì¼ A,,,í”„ë¡œíŒŒì¼ B,,,\n,ì˜¨ë„â„ƒ,ë¶„,ì´ˆ,ì˜¨ë„â„ƒ,ë¶„,ì´ˆ\n"
        data = ",120,0,0,115,0,0\n,140,0,40,150,1,5\n,160,1,23,170,1,40\n"
    else: # êµ¬ê°„ ì…ë ¥
        header = ",í”„ë¡œíŒŒì¼ A,,í”„ë¡œíŒŒì¼ B,,\n,ì˜¨ë„â„ƒ,êµ¬ê°„(ì´ˆ),ì˜¨ë„â„ƒ,êµ¬ê°„(ì´ˆ)\n"
        data = ",120,,115,\n,140,40,150,65\n,160,43,170,35\n"
    
    # [ìˆ˜ì •] ì—‘ì…€ì—ì„œ í•œê¸€ì´ ê¹¨ì§€ì§€ ì•Šë„ë¡ 'utf-8-sig' ì¸ì½”ë”©ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
    return (header + data).encode('utf-8-sig')

# ==============================================================================
# UI ë Œë”ë§
# ==============================================================================
st.set_page_config(layout="wide", page_title="ì´ì¹´ì™€ ë¡œìŠ¤íŒ… í”„ë¡œíŒŒì¼ ê³„ì‚° íˆ´")
st.title("â˜• ì´ì¹´ì™€ ë¡œìŠ¤íŒ… í”„ë¡œíŒŒì¼ ê³„ì‚° íˆ´ (CSV Uploader)")

graph_data = {}

st.markdown("### 1. ë¶„ì„í•  íŒŒì¼ì˜ í˜•ì‹ì„ ì„ íƒí•˜ì„¸ìš”.")
input_method = st.radio("íŒŒì¼ í˜•ì‹ ì„ íƒ", ["ì‹œê°„ ì…ë ¥", "êµ¬ê°„ ì…ë ¥"], horizontal=True, label_visibility="collapsed")

col1, col2 = st.columns(2)
with col1:
    st.download_button(
        label="ğŸ“¥ CSV í…œí”Œë¦¿ ë‹¤ìš´ë¡œë“œ",
        data=create_template_csv(input_method),
        file_name=f"template_{'time' if input_method == 'ì‹œê°„ ì…ë ¥' else 'interval'}.csv"
    )
with col2:
    uploaded_file = st.file_uploader("**2. í”„ë¡œíŒŒì¼ CSV íŒŒì¼ì„ ì—…ë¡œë“œí•˜ì„¸ìš”.**", type=['csv'], label_visibility="collapsed")

st.markdown("---")

if uploaded_file is not None:
    with st.spinner("íŒŒì¼ ì²˜ë¦¬ ì¤‘..."):
        try:
            raw_df = pd.read_csv(uploaded_file, header=None, encoding='utf-8-sig')

            # --- íŒŒì‹± ë¡œì§ ---
            parsed_profiles = {}
            profile_names_row = raw_df.iloc[0]
            header_row = raw_df.iloc[1]
            data_rows = raw_df.iloc[2:]

            cols_per_profile = 4 if input_method == 'ì‹œê°„ ì…ë ¥' else 3

            for col_idx, name in profile_names_row.dropna().items():
                if col_idx % cols_per_profile == 1: # í”„ë¡œíŒŒì¼ ì´ë¦„ì´ ì˜¬ë°”ë¥¸ ìœ„ì¹˜ì— ìˆëŠ”ì§€ í™•ì¸
                    try:
                        chunk_cols = range(col_idx, col_idx + cols_per_profile - 1)
                        profile_chunk = data_rows.iloc[:, chunk_cols]
                        profile_chunk.columns = header_row[chunk_cols].values
                        profile_chunk.dropna(how='all', inplace=True)
                        parsed_profiles[name] = profile_chunk
                    except Exception:
                        continue

            if not parsed_profiles:
                st.error("íŒŒì¼ì—ì„œ ìœ íš¨í•œ í”„ë¡œíŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. CSV í…œí”Œë¦¿ ì–‘ì‹ì„ í™•ì¸í•˜ì„¸ìš”.")
            else:
                for name, df in parsed_profiles.items():
                    calculated = process_profile_data(df, input_method)
                    if calculated is not None:
                        graph_data[name] = calculated # ë³´ê°„ ì—†ì´ ê³„ì‚°ëœ ë°ì´í„°ë§Œ ì €ì¥

        except Exception as e:
            st.error(f"íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {e}")

# --- ì‚¬ì´ë“œë°” ë° ê·¸ë˜í”„/ë¶„ì„ íŒ¨ë„ ---
with st.sidebar:
    st.header("ë³´ê¸° ì˜µì…˜")
    if graph_data:
        selected_profiles = [name for name in graph_data.keys() if st.checkbox(name, value=True, key=f"select_{name}")]
        st.divider()
        show_ror_graph = st.checkbox("ROR ê·¸ë˜í”„ í‘œì‹œ", value=True)
    else:
        selected_profiles = []
        show_ror_graph = True
    st.divider()
    with st.expander("ğŸ› ï¸ ê°œë°œì ëª¨ë“œ"):
        st.write("`graph_data`ì˜ í”„ë¡œíŒŒì¼ ê°œìˆ˜: " + str(len(graph_data)))

st.header("ğŸ“Š í”„ë¡œíŒŒì¼ ë¹„êµ ê·¸ë˜í”„ ë° ë¶„ì„")
col_graph, col_info = st.columns([3, 1])

with col_graph:
    fig = go.Figure()
    colors = px.colors.qualitative.Plotly
    if not graph_data:
        st.info("CSV íŒŒì¼ì„ ì—…ë¡œë“œí•˜ì—¬ ë¶„ì„ì„ ì‹œì‘í•˜ì„¸ìš”.")
    else:
        for i, name in enumerate(selected_profiles):
            if name in graph_data:
                df_calc = graph_data.get(name)
                color = colors[i % len(colors)]
                if df_calc is not None:
                    fig.add_trace(go.Scatter(x=df_calc['ëˆ„ì (ì´ˆ)'], y=df_calc['ì˜¨ë„â„ƒ'], name=f'{name} - ì˜¨ë„', mode='lines+markers', line=dict(color=color), marker=dict(size=8), hoverinfo='none'))
                    if show_ror_graph:
                        fig.add_trace(go.Scatter(x=df_calc['ëˆ„ì (ì´ˆ)'], y=df_calc['ROR(ì´ˆë‹¹)'], name=f'{name} - ROR', mode='lines+markers', line=dict(color=color, dash='dot'), yaxis='y2', marker=dict(size=8), hoverinfo='none'))

    fig.update_layout(height=600, xaxis=dict(title='ì‹œê°„ í•©ê³„ (ì´ˆ)', range=[0, 360]), yaxis=dict(title='ì˜¨ë„ (Â°C)', range=[85, 235]), yaxis2=dict(title='ROR(ì´ˆë‹¹)', overlaying='y', side='right', range=[0, 0.75]), legend=dict(x=0, y=1.1, orientation='h'), hovermode='x unified')
    selected_points = plotly_events(fig, hover_event=True, key="graph_hover_events")

with col_info:
    last_hovered_time = selected_points[0]['x'] if selected_points else None
    display_hover_info(last_hovered_time, selected_profiles, graph_data, px.colors.qualitative.Plotly)
