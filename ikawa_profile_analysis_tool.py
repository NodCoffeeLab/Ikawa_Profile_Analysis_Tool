# -*- coding: utf-8 -*-
"""Ikawa_Profile_Analysis_Tool

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VAxAvlop0rAM0zP-S6ix7y3leWJh-lav
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile Ikawa_Profile_Analysis_Tool.py
# # Ikawa_Profile_Analysis_Tool.py
# # -*- coding: utf-8 -*-
# 
# import streamlit as st
# import pandas as pd
# import numpy as np
# import plotly.graph_objects as go
# import plotly.express as px
# from streamlit_plotly_events import plotly_events
# import io
# 
# # ==============================================================================
# # í•µì‹¬ í•¨ìˆ˜
# # ==============================================================================
# 
# @st.cache_data
# def process_uploaded_file(file_content, input_method):
#     """ì—…ë¡œë“œëœ íŒŒì¼ ì „ì²´ë¥¼ ì½ê³  ì²˜ë¦¬í•˜ëŠ” ê³¼ì •ì„ ìºì‹œí•©ë‹ˆë‹¤."""
#     graph_data = {}
#     try:
#         raw_df = pd.read_excel(io.BytesIO(file_content), header=None)
# 
#         # --- íŒŒì‹± ë¡œì§ ---
#         parsed_profiles = {}
#         profile_names_row = raw_df.iloc[0]
#         cols_per_profile = 3 if input_method == 'ì‹œê°„ ì…ë ¥' else 2
#         for col_idx, name in profile_names_row.dropna().items():
#             try:
#                 profile_chunk = raw_df.iloc[2:, col_idx:col_idx + cols_per_profile]
#                 profile_chunk.columns = raw_df.iloc[1, col_idx:col_idx + cols_per_profile].values
#                 profile_chunk.dropna(how='all', inplace=True)
#                 parsed_profiles[name] = profile_chunk
#             except Exception:
#                 continue
# 
#         if not parsed_profiles:
#             st.error("íŒŒì¼ì—ì„œ ìœ íš¨í•œ í”„ë¡œíŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
#             return {}
# 
#         # --- ê³„ì‚° ë¡œì§ ---
#         for name, df in parsed_profiles.items():
#             calculated = process_profile_data(df, input_method)
#             if calculated is not None:
#                 graph_data[name] = {'calculated': calculated, 'interpolated': None}
#             else:
#                 st.warning(f"'{name}' í”„ë¡œíŒŒì¼ì— ìœ íš¨í•œ ë°ì´í„°ê°€ ì—†ì–´ ê·¸ë˜í”„ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
# 
#         return graph_data
# 
#     except Exception as e:
#         st.error(f"íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {e}")
#         return {}
# 
# def process_profile_data(df: pd.DataFrame, input_method: str) -> pd.DataFrame | None:
#     """ë‹¨ì¼ í”„ë¡œíŒŒì¼ DFë¥¼ ë°›ì•„ ëª¨ë“  ì‹œê°„/ROR ê³„ì‚°ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤."""
#     processed_df = df.copy()
#     cols_to_numeric = ['ì˜¨ë„â„ƒ', 'ë¶„', 'ì´ˆ', 'êµ¬ê°„(ì´ˆ)']
#     for col in cols_to_numeric:
#         if col in processed_df.columns:
#             processed_df[col] = pd.to_numeric(processed_df[col], errors='coerce')
#     processed_df.dropna(subset=['ì˜¨ë„â„ƒ'], inplace=True)
#     if processed_df.empty: return None
#     processed_df.reset_index(drop=True, inplace=True)
#     processed_df.insert(0, 'ë²ˆí˜¸', processed_df.index)
#     if input_method == 'ì‹œê°„ ì…ë ¥':
#         processed_df['ë¶„'].fillna(0, inplace=True)
#         processed_df['ì´ˆ'].fillna(0, inplace=True)
#         total_seconds = processed_df['ë¶„'] * 60 + processed_df['ì´ˆ']
#         processed_df['êµ¬ê°„(ì´ˆ)'] = total_seconds.diff()
#     else: # êµ¬ê°„ ì…ë ¥
#         processed_df['êµ¬ê°„(ì´ˆ)'].fillna(0, inplace=True)
#         total_seconds = processed_df['êµ¬ê°„(ì´ˆ)'].cumsum()
#         processed_df['ë¶„'] = (total_seconds // 60).astype('Int64')
#         processed_df['ì´ˆ'] = (total_seconds % 60).astype('Int64')
#     processed_df['ëˆ„ì (ì´ˆ)'] = processed_df['êµ¬ê°„(ì´ˆ)'].cumsum().fillna(0)
#     temp_diff = processed_df['ì˜¨ë„â„ƒ'].diff()
#     time_diff = processed_df['êµ¬ê°„(ì´ˆ)']
#     where_condition = time_diff.fillna(0) != 0
#     ror_per_sec = np.divide(temp_diff, time_diff, out=np.zeros_like(temp_diff, dtype=float), where=where_condition)
#     processed_df['ROR(ì´ˆë‹¹)'] = pd.Series(ror_per_sec).fillna(0)
#     return processed_df
# 
# def interpolate_data(df_calc: pd.DataFrame) -> pd.DataFrame | None:
#     # ë³´ê°„ ì œê±°ë¡œ ì¸í•´ ì›ë³¸ ë°ì´í„°ë¥¼ ê·¸ëŒ€ë¡œ ë°˜í™˜
#     return df_calc
# 
# def display_hover_info(hovered_time, selected_profiles, graph_data, colors):
#     """ê·¸ë˜í”„ í˜¸ë²„ ì‹œ ë¶„ì„ íŒ¨ë„ì— ì •ë³´ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤."""
#     st.markdown("#### ë¶„ì„ ì •ë³´")
#     if hovered_time is None or not graph_data:
#         st.info("ê·¸ë˜í”„ ìœ„ì— ë§ˆìš°ìŠ¤ë¥¼ ì˜¬ë¦¬ë©´ ìƒì„¸ ì •ë³´ê°€ í‘œì‹œë©ë‹ˆë‹¤.")
#         return
#     hover_sec = int(hovered_time)
# 
#     try:
#         first_profile_name = next(name for name in selected_profiles if name in graph_data and graph_data[name]['calculated'] is not None)
#         df_calc_first = graph_data[first_profile_name]['calculated']
# 
#         # í˜¸ë²„ ìœ„ì¹˜ì˜ ì˜¨ë„ ê³„ì‚° (ì‹¤ì œ ë°ì´í„° í¬ì¸íŠ¸ ê°„ì˜ ì„ í˜• ë³´ê°„ìœ¼ë¡œ ì˜¨ë„ ì¶”ì •)
#         temp_at_hover = np.interp(hover_sec, df_calc_first['ëˆ„ì (ì´ˆ)'], df_calc_first['ì˜¨ë„â„ƒ'])
#         st.markdown(f"**{hover_sec // 60}ë¶„ {hover_sec % 60:02d}ì´ˆ ({hover_sec}ì´ˆ) / {temp_at_hover:.1f}â„ƒ**")
#     except (StopIteration, KeyError, IndexError):
#          return
#     st.divider()
#     for i, name in enumerate(selected_profiles):
#         if name in graph_data:
#             data = graph_data.get(name, {})
#             df_calc = data.get('calculated')
#             color = colors[i % len(colors)]
# 
#             current_segment = df_calc[df_calc['ëˆ„ì (ì´ˆ)'] <= hover_sec].iloc[-1:]
#             if current_segment.empty: continue
# 
#             idx = current_segment.index[0]
#             current_time = current_segment['ëˆ„ì (ì´ˆ)'].iloc[0]
#             current_ror = current_segment['ROR(ì´ˆë‹¹)'].iloc[0]
#             current_temp = current_segment['ì˜¨ë„â„ƒ'].iloc[0]
# 
#             is_on_point = abs(current_time - hover_sec) <= 0.5
# 
#             if is_on_point:
#                 display_temp = current_temp
#                 point_num = current_segment['ë²ˆí˜¸'].iloc[0]
#                 st.markdown(f"<span style='color:{color};'>â—</span> **{name}**: í¬ì¸íŠ¸ {int(point_num)}: {display_temp:.1f}â„ƒ (ì´ˆë‹¹ {current_ror:.3f}â„ƒ ìƒìŠ¹)", unsafe_allow_html=True)
#             else:
#                 time_in_segment = hover_sec - current_time
#                 interp_temp = current_temp + current_ror * time_in_segment
# 
#                 st.markdown(f"<span style='color:{color};'>â—</span> **{name}**: í¬ì¸íŠ¸ {int(current_segment['ë²ˆí˜¸'].iloc[0])}-{int(current_segment['ë²ˆí˜¸'].iloc[0]) + 1} êµ¬ê°„: {interp_temp:.1f}â„ƒ (ì´ˆë‹¹ {current_ror:.3f}â„ƒ ìƒìŠ¹)", unsafe_allow_html=True)
# 
# @st.cache_data
# def create_template_excel(format_type):
#     output = io.BytesIO()
#     with pd.ExcelWriter(output, engine='openpyxl') as writer:
#         if format_type == 'ì‹œê°„ ì…ë ¥':
#             df1 = pd.DataFrame({'ì˜¨ë„â„ƒ': [120, 140, 160], 'ë¶„': [0, 0, 1], 'ì´ˆ': [0, 40, 23]})
#             df2 = pd.DataFrame({'ì˜¨ë„â„ƒ': [115, 150, 170], 'ë¶„': [0, 1, 1], 'ì´ˆ': [0, 5, 40]})
#             df_a = pd.concat([pd.DataFrame([['í”„ë¡œíŒŒì¼ A', '', '']], columns=['A', 'B', 'C']), pd.DataFrame([['ì˜¨ë„â„ƒ', 'ë¶„', 'ì´ˆ']], columns=['A', 'B', 'C']), df1.rename(columns={'ì˜¨ë„â„ƒ': 'A', 'ë¶„': 'B', 'ì´ˆ': 'C'})], ignore_index=True)
#             df_b = pd.concat([pd.DataFrame([['í”„ë¡œíŒŒì¼ B', '', '']], columns=['D', 'E', 'F']), pd.DataFrame([['ì˜¨ë„â„ƒ', 'ë¶„', 'ì´ˆ']], columns=['D', 'E', 'F']), df2.rename(columns={'ì˜¨ë„â„ƒ': 'D', 'ë¶„': 'E', 'ì´ˆ': 'F'})], ignore_index=True)
#             df_final = pd.concat([df_a, df_b], axis=1)
#         else: # êµ¬ê°„ ì…ë ¥
#             df1 = pd.DataFrame({'ì˜¨ë„â„ƒ': [120, 140, 160], 'êµ¬ê°„(ì´ˆ)': [np.nan, 40, 43]})
#             df2 = pd.DataFrame({'ì˜¨ë„â„ƒ': [115, 150, 170], 'êµ¬ê°„(ì´ˆ)': [np.nan, 65, 35]})
#             df_a = pd.concat([pd.DataFrame([['í”„ë¡œíŒŒì¼ A', '']], columns=['A', 'B']), pd.DataFrame([['ì˜¨ë„â„ƒ', 'êµ¬ê°„(ì´ˆ)']], columns=['A', 'B']), df1.rename(columns={'ì˜¨ë„â„ƒ': 'A', 'êµ¬ê°„(ì´ˆ)': 'B'})], ignore_index=True)
#             df_b = pd.concat([pd.DataFrame([['í”„ë¡œíŒŒì¼ B', '']], columns=['C', 'D']), pd.DataFrame([['ì˜¨ë„â„ƒ', 'êµ¬ê°„(ì´ˆ)']], columns=['C', 'D']), df2.rename(columns={'ì˜¨ë„â„ƒ': 'C', 'êµ¬ê°„(ì´ˆ)': 'D'})], ignore_index=True)
#             df_final = pd.concat([df_a, df_b], axis=1)
#         df_final.to_excel(writer, sheet_name='profiles', index=False, header=False)
#     return output.getvalue()
# 
# # ==============================================================================
# # UI ë Œë”ë§
# # ==============================================================================
# st.set_page_config(layout="wide", page_title="ì´ì¹´ì™€ ë¡œìŠ¤íŒ… í”„ë¡œíŒŒì¼ ê³„ì‚° íˆ´ v7.0")
# st.title("â˜• ì´ì¹´ì™€ ë¡œìŠ¤íŒ… í”„ë¡œíŒŒì¼ ê³„ì‚° íˆ´ v7.0 (Final Stable Version)")
# 
# if 'graph_data' not in st.session_state:
#     st.session_state.graph_data = {}
# 
# st.markdown("### 1. ë¶„ì„í•  íŒŒì¼ì˜ í˜•ì‹ì„ ì„ íƒí•˜ì„¸ìš”.")
# input_method = st.radio("íŒŒì¼ í˜•ì‹ ì„ íƒ", ["ì‹œê°„ ì…ë ¥", "êµ¬ê°„ ì…ë ¥"], horizontal=True, label_visibility="collapsed")
# 
# col1, col2 = st.columns(2)
# with col1:
#     st.download_button(label="ğŸ“¥ ì—‘ì…€ í…œí”Œë¦¿ ë‹¤ìš´ë¡œë“œ", data=create_template_excel(input_method), file_name=f"template.xlsx")
# with col2:
#     uploaded_file = st.file_uploader("**2. í”„ë¡œíŒŒì¼ ì—‘ì…€ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ì„¸ìš”.**", type=['xlsx'], label_visibility="collapsed")
# 
# st.markdown("---")
# 
# graph_data = {}
# if uploaded_file is not None:
#     with st.spinner("íŒŒì¼ ì²˜ë¦¬ ì¤‘..."):
#         file_bytes = uploaded_file.getvalue()
#         graph_data = process_uploaded_file(file_bytes, input_method)
#         st.session_state.graph_data = graph_data
# 
# with st.sidebar:
#     st.header("ë³´ê¸° ì˜µì…˜")
#     if graph_data:
#         selected_profiles = [name for name in graph_data.keys() if st.checkbox(name, value=True, key=f"select_{name}")]
#         st.divider()
#         show_ror_graph = st.checkbox("ROR ê·¸ë˜í”„ í‘œì‹œ", value=True)
#     else:
#         selected_profiles = []
#         show_ror_graph = True
#     st.divider()
#     with st.expander("ğŸ› ï¸ ê°œë°œì ëª¨ë“œ"):
#         st.write("`graph_data` ë‚´ìš©:")
#         st.json({k: {
#             'calculated': v['calculated'].to_string() if v.get('calculated') is not None else "None",
#             'interpolated': 'ì œê±°ë¨ (ì„±ëŠ¥)'
#         } for k, v in graph_data.items()} if graph_data else {})
# 
# st.header("ğŸ“Š í”„ë¡œíŒŒì¼ ë¹„êµ ê·¸ë˜í”„ ë° ë¶„ì„")
# col_graph, col_info = st.columns([3, 1])
# 
# with col_graph:
#     fig = go.Figure()
#     colors = px.colors.qualitative.Plotly
#     if not graph_data:
#         st.info("ì—‘ì…€ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ì—¬ ë¶„ì„ì„ ì‹œì‘í•˜ì„¸ìš”.")
#     else:
#         for i, name in enumerate(selected_profiles):
#             if name in graph_data and name in selected_profiles:
#                 data = graph_data.get(name, {})
#                 df_calc = data.get('calculated')
#                 color = colors[i % len(colors)]
#                 if df_calc is not None:
#                     fig.add_trace(go.Scatter(x=df_calc['ëˆ„ì (ì´ˆ)'], y=df_calc['ì˜¨ë„â„ƒ'], name=f'{name} - ì˜¨ë„', mode='lines+markers', line=dict(color=color), marker=dict(size=8), showlegend=True, hoverinfo='none'))
#                     if show_ror_graph:
#                         fig.add_trace(go.Scatter(x=df_calc['ëˆ„ì (ì´ˆ)'], y=df_calc['ROR(ì´ˆë‹¹)'], name=f'{name} - ROR', mode='lines+markers', line=dict(color=color, dash='dot'), yaxis='y2', marker=dict(size=8), showlegend=True, hoverinfo='none'))
# 
#     fig.update_layout(height=600, xaxis=dict(title='ì‹œê°„ í•©ê³„ (ì´ˆ)', range=[0, 360]), yaxis=dict(title='ì˜¨ë„ (Â°C)', range=[85, 235]), yaxis2=dict(title='ROR(ì´ˆë‹¹)', overlaying='y', side='right', range=[0, 0.75]), legend=dict(x=0, y=1.1, orientation='h'), hovermode='x unified')
#     selected_points = plotly_events(fig, hover_event=True, key="graph_hover_events")
# 
# with col_info:
#     last_hovered_time = selected_points[0]['x'] if selected_points else None
#     display_hover_info(last_hovered_time, selected_profiles, graph_data, px.colors.qualitative.Plotly)